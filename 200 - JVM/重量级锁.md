JVM 会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。

[[Java 线程|线程]]的阻塞和唤醒，都是依靠操作系统来完成的。对于符合 [[posix]] 接口的操作系统（如 macOS 和巨大部分的 Linux），上述操作是通过 [[pthread]] 的[[互斥锁]]来实现的。这些操作涉及系统调用，需要从操作系统的[[用户态]]切换至[[内核态]]，其开销非常之大。

为了尽量避免昂贵的线程阻塞、唤醒操作，JVM 会在线程进入阻塞状态之前，已经被唤醒后竞争不到锁的情况下，进入[[自旋状态]]，在处理器上空跑并且轮询锁是否被释放。如果此时锁恰好被释放了，那么当前线程便无须进入阻塞状态，而是直接获得这把锁。

JVM 使用自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的次数。

自旋状态还带来另外一个副作用，那便是不公平的锁机制。处于阻塞状态的线程，并没有办法立刻竞争被释放的锁。然后。处于自旋状态的线程，则很有可能优先获得这把锁。